{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/anatole/source/css/blog_basic.css","path":"css/blog_basic.css","modified":0,"renderable":1},{"_id":"themes/anatole/source/css/blog_basic.min.css","path":"css/blog_basic.min.css","modified":0,"renderable":1},{"_id":"themes/anatole/source/css/font-awesome.css","path":"css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/anatole/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/anatole/source/css/font-awesome.min.css","path":"css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/anatole/source/css/style.min.css","path":"css/style.min.css","modified":0,"renderable":1},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/anatole/source/images/codewars.png","path":"images/codewars.png","modified":0,"renderable":1},{"_id":"themes/anatole/source/images/favicon.png","path":"images/favicon.png","modified":0,"renderable":1},{"_id":"themes/anatole/source/images/index_circle_img.png","path":"images/index_circle_img.png","modified":0,"renderable":1},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/anatole/source/images/index_img.jpeg","path":"images/index_img.jpeg","modified":0,"renderable":1},{"_id":"themes/anatole/source/images/logo.png","path":"images/logo.png","modified":0,"renderable":1},{"_id":"themes/anatole/source/images/logo@2x.png","path":"images/logo@2x.png","modified":0,"renderable":1},{"_id":"themes/anatole/source/js/jquery-migrate-1.2.1.min.js","path":"js/jquery-migrate-1.2.1.min.js","modified":0,"renderable":1},{"_id":"themes/anatole/source/js/jquery.appear.js","path":"js/jquery.appear.js","modified":0,"renderable":1},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/anatole/source/js/jquery-1.9.0.min.js","path":"js/jquery-1.9.0.min.js","modified":0,"renderable":1},{"_id":"themes/anatole/source/images/self_img.png","path":"images/self_img.png","modified":0,"renderable":1},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/anatole/.DS_Store","hash":"61d4653525ee800306d888d998f91174144e6d64","modified":1512872770000},{"_id":"themes/anatole/.gitignore","hash":"9fcbb05b158b5d3ba1ee60d38889e05e8b0f3f2a","modified":1494448682000},{"_id":"themes/anatole/LICENSE","hash":"359cb81298c1fdbccf531548fc097466b0151be4","modified":1494448682000},{"_id":"themes/anatole/_config.yml","hash":"257d32cd5d969822ecb43ead3e9eab4437169942","modified":1512883682000},{"_id":"themes/anatole/package.json","hash":"cf731a3ebf3913747fccb6c4c6615eba7d7e88a4","modified":1494448682000},{"_id":"source/_posts/Canvas画出毛边？这里是一种抗锯齿的方法.md","hash":"8061c56b2a59dc483fb8723656e6b5ca29df0a22","modified":1512896429000},{"_id":"source/_posts/你可能不知道的React之setState.md","hash":"a0eabaefec3c3e727875f320108aa52ed5c2bac2","modified":1512895389000},{"_id":"source/_posts/使用VPS搭建VPN-–-PPTP.md","hash":"17b01cb809b88553fa88489e09911aa76ee41972","modified":1512895223000},{"_id":"source/_posts/浅谈js异步.md","hash":"8d77df445fed26751d01fb96e834b21dc4a240ff","modified":1512895016000},{"_id":"source/links/index.md","hash":"ff9be225e2d8ac5db49fd34bf61406d44b4acf2f","modified":1512889418000},{"_id":"themes/anatole/languages/zh-cn.yml","hash":"dab1823e036f4adb3b7ae9efe95a37a15e47bec2","modified":1494448682000},{"_id":"themes/anatole/layout/archive.jade","hash":"1a161404966000b25a84762f08da3ca60af146bc","modified":1512874871000},{"_id":"themes/anatole/layout/category.jade","hash":"ae894ef4baee4a0c7c8e66641166061e789f1fa7","modified":1494448682000},{"_id":"themes/anatole/layout/index.jade","hash":"77fa1296b90e14ef57ac0603dfadeeec8d417cce","modified":1512890720000},{"_id":"themes/anatole/layout/links.jade","hash":"f98c7d63de650d5423c06aecfe66028c9dd4979a","modified":1512890205000},{"_id":"themes/anatole/layout/mixins.jade","hash":"107bfd2fe10de0d8b110c13bb1168af79e62a37c","modified":1494448682000},{"_id":"themes/anatole/layout/page.jade","hash":"c70466ef1b07ae97f0de9e0a5140f22f47a66143","modified":1512889667000},{"_id":"themes/anatole/layout/post.jade","hash":"696c79479b085cff235e91c9bc855556dea19609","modified":1512879781000},{"_id":"themes/anatole/layout/tag.jade","hash":"7017a8bae4f4a412dafb556772bdcf2cfddeb79f","modified":1494448682000},{"_id":"themes/anatole/source/.DS_Store","hash":"495dc0d217dbc3e7cb0c015a4aa9af3e7011d37f","modified":1512882881000},{"_id":"themes/anatole/layout/partial/footer.jade","hash":"df7b9a2cecc0fa4920adabe0f5464501a178f695","modified":1512880090000},{"_id":"themes/anatole/layout/partial/comments.jade","hash":"6d749e695e30ecfc0a2de2b443fd361f5f2a5cff","modified":1494448682000},{"_id":"themes/anatole/layout/partial/head.jade","hash":"7a22af1aacae3efaf2754e11bc6c616d7b18c120","modified":1512892241000},{"_id":"themes/anatole/layout/partial/layout.jade","hash":"002adbd16fb0ebbd2cfac934eef52a85b8431849","modified":1512876304000},{"_id":"themes/anatole/layout/partial/nav.jade","hash":"b8a21d4b33a85eb8b42d48bd97cd6dca9899d383","modified":1512886708000},{"_id":"themes/anatole/layout/partial/personalDesc.jade","hash":"211b4df192c33e0a4d40e3246376e201c5c883d6","modified":1512891460000},{"_id":"themes/anatole/layout/partial/post_layout.jade","hash":"5ccc195c3cca0483b898f55b3c23c41a48bba6a9","modified":1512878887000},{"_id":"themes/anatole/layout/partial/sidebar.jade","hash":"296efc67b89919b74ac144b88c6d2b9d9a93546d","modified":1512890861000},{"_id":"themes/anatole/source/css/blog_basic.css","hash":"7db88f0873e858b21a4c981c8481708ad9117478","modified":1512878154000},{"_id":"themes/anatole/source/css/blog_basic.min.css","hash":"e13eb39a75adfd723fe6a0a952f22828485fbad4","modified":1512878154000},{"_id":"themes/anatole/source/css/font-awesome.css","hash":"95d0b0c4d11105c81be1857b744076a1d2bed918","modified":1494448682000},{"_id":"themes/anatole/source/css/style.css","hash":"6bcd6ac5872bbb00d9127836d574d4e28264fd2f","modified":1512895294000},{"_id":"themes/anatole/source/css/font-awesome.min.css","hash":"ff6ed1c90db59f34e8cd1d41db0206f335d394a8","modified":1512878218000},{"_id":"themes/anatole/source/css/style.min.css","hash":"61dd5b7a17be9c56c58679f05f9b287c0b212e17","modified":1512895295000},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.eot","hash":"0183979056f0b87616cd99d5c54a48f3b771eee6","modified":1494448682000},{"_id":"themes/anatole/source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1512882636000},{"_id":"themes/anatole/source/images/codewars.png","hash":"28fc059c972af421312b82f6ff228d1ed7c44886","modified":1512883607000},{"_id":"themes/anatole/source/images/favicon.png","hash":"d659236704308954da9d64b101c4f54cc3f3255c","modified":1494448682000},{"_id":"themes/anatole/source/images/index_circle_img.png","hash":"2e0388b270ceabe5180f8de48005d262ff885dce","modified":1512892132000},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.woff","hash":"7d65e0227d0d7cdc1718119cd2a7dce0638f151c","modified":1494448682000},{"_id":"themes/anatole/source/images/index_img.jpeg","hash":"ce0d15720ea938dd44fcc9bb4ffef351f25fdf48","modified":1512880734000},{"_id":"themes/anatole/source/images/logo.png","hash":"41bdf2ebd8cc193ad82a211758af827d891b1a90","modified":1494448682000},{"_id":"themes/anatole/source/images/logo@2x.png","hash":"49c3fa97724abf53861bf11356ea9ba5bcb11576","modified":1494448682000},{"_id":"themes/anatole/source/js/jquery-migrate-1.2.1.min.js","hash":"743052320809514fb788fe1d3df37fc87ce90452","modified":1494448682000},{"_id":"themes/anatole/source/js/jquery.appear.js","hash":"2e34212e6b6d02d152c039780eccc3d9428192da","modified":1512876539000},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.ttf","hash":"6225ccc4ec94d060f19efab97ca42d842845b949","modified":1494448682000},{"_id":"themes/anatole/source/js/jquery-1.9.0.min.js","hash":"002da8cbe90fcf32fbdebb72386125079e3805ee","modified":1512876198000},{"_id":"themes/anatole/source/images/self_img.png","hash":"1e6d328ae5df0fe2481d3c6f6943571c814521d6","modified":1512882864000},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.svg","hash":"cd980eab6db5fa57db670cb2e4278e67e1a4d6c9","modified":1494448682000}],"Category":[],"Data":[],"Page":[{"title":"links","date":"2017-12-10T06:52:19.000Z","_content":"","source":"links/index.md","raw":"---\ntitle: links\ndate: 2017-12-10 14:52:19\n---\n","updated":"2017-12-10T07:03:38.000Z","path":"links/index.html","comments":1,"layout":"page","_id":"cjb0ivqie0001jawryc4d6o8v","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Canvas画出毛边？这里是一种抗锯齿的方法","date":"2017-12-10T08:43:41.000Z","_content":"\n> Canvas可以轻易的解决很多传统方法处理起来十分费力的问题，目前老式浏览器占比越来越小，尤其是在移动端，许多问题都可以放心的使用Canvas进行处理。<br/>\n然而在最近使用的过程中我遇到了一个问题，使用Canvas绘制出的曲线，存在很大的毛边，本文简单介绍一种可以消除毛边的简单方法。\n\n## 问题\n问题的由来是我在使用Canvas绘制一个圆形进度条时，在绘制出进度条后发现进度条显示的质量很差，整个圆形的周边充斥着毛边，因此寻求一种有效的抗锯齿解决办法。\n\n![](http://s.songzhj.com/img/20171210/juchi.png)\n\n## 解决办法\n\n为了解决锯齿的问题，我们使用一种简单的缩放方式来减小绘制图形的锯齿。\n该方法有几个关键点：\n\n- 将canvas元素放入一个固定宽高的容器中，并且正常给canvas一个宽高（通常与外层容器一样即可）\n````html\n<div class=\"m-canvas-container\">\n    <canvas id=\"canvas\" height=\"200\" width=\"200\"></canvas>\n</div>\n````\n\n- 在css中将canvas元素的width设置为100%。\n````css\n#canvas {\n    width: 100%;\n}\n````\n\n- 在绘制canvas时，定义一个缩放参数SCALE，将canvas的height和width扩大SCALE倍，后续所有绘制都放大SCALE倍。\n````javascript\nfunction draw() {\n    canvas.width = SCALE * canvas.width;\n    canvas.height = SCALE * canvas.height;\n}\n````","source":"_posts/Canvas画出毛边？这里是一种抗锯齿的方法.md","raw":"---\ntitle: Canvas画出毛边？这里是一种抗锯齿的方法\ndate: 2017-12-10 16:43:41\ntags:\n---\n\n> Canvas可以轻易的解决很多传统方法处理起来十分费力的问题，目前老式浏览器占比越来越小，尤其是在移动端，许多问题都可以放心的使用Canvas进行处理。<br/>\n然而在最近使用的过程中我遇到了一个问题，使用Canvas绘制出的曲线，存在很大的毛边，本文简单介绍一种可以消除毛边的简单方法。\n\n## 问题\n问题的由来是我在使用Canvas绘制一个圆形进度条时，在绘制出进度条后发现进度条显示的质量很差，整个圆形的周边充斥着毛边，因此寻求一种有效的抗锯齿解决办法。\n\n![](http://s.songzhj.com/img/20171210/juchi.png)\n\n## 解决办法\n\n为了解决锯齿的问题，我们使用一种简单的缩放方式来减小绘制图形的锯齿。\n该方法有几个关键点：\n\n- 将canvas元素放入一个固定宽高的容器中，并且正常给canvas一个宽高（通常与外层容器一样即可）\n````html\n<div class=\"m-canvas-container\">\n    <canvas id=\"canvas\" height=\"200\" width=\"200\"></canvas>\n</div>\n````\n\n- 在css中将canvas元素的width设置为100%。\n````css\n#canvas {\n    width: 100%;\n}\n````\n\n- 在绘制canvas时，定义一个缩放参数SCALE，将canvas的height和width扩大SCALE倍，后续所有绘制都放大SCALE倍。\n````javascript\nfunction draw() {\n    canvas.width = SCALE * canvas.width;\n    canvas.height = SCALE * canvas.height;\n}\n````","slug":"Canvas画出毛边？这里是一种抗锯齿的方法","published":1,"updated":"2017-12-10T09:00:29.000Z","_id":"cjb0ivqi70000jawrcf05uy7z","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>Canvas可以轻易的解决很多传统方法处理起来十分费力的问题，目前老式浏览器占比越来越小，尤其是在移动端，许多问题都可以放心的使用Canvas进行处理。<br><br>然而在最近使用的过程中我遇到了一个问题，使用Canvas绘制出的曲线，存在很大的毛边，本文简单介绍一种可以消除毛边的简单方法。</p>\n</blockquote>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>问题的由来是我在使用Canvas绘制一个圆形进度条时，在绘制出进度条后发现进度条显示的质量很差，整个圆形的周边充斥着毛边，因此寻求一种有效的抗锯齿解决办法。</p>\n<p><img src=\"http://s.songzhj.com/img/20171210/juchi.png\" alt=\"\"></p>\n<h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><p>为了解决锯齿的问题，我们使用一种简单的缩放方式来减小绘制图形的锯齿。<br>该方法有几个关键点：</p>\n<ul>\n<li><p>将canvas元素放入一个固定宽高的容器中，并且正常给canvas一个宽高（通常与外层容器一样即可）</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"m-canvas-container\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">canvas</span> <span class=\"attr\">id</span>=<span class=\"string\">\"canvas\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"200\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"200\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">canvas</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在css中将canvas元素的width设置为100%。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#canvas</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在绘制canvas时，定义一个缩放参数SCALE，将canvas的height和width扩大SCALE倍，后续所有绘制都放大SCALE倍。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">draw</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    canvas.width = SCALE * canvas.width;</span><br><span class=\"line\">    canvas.height = SCALE * canvas.height;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Canvas可以轻易的解决很多传统方法处理起来十分费力的问题，目前老式浏览器占比越来越小，尤其是在移动端，许多问题都可以放心的使用Canvas进行处理。<br><br>然而在最近使用的过程中我遇到了一个问题，使用Canvas绘制出的曲线，存在很大的毛边，本文简单介绍一种可以消除毛边的简单方法。</p>\n</blockquote>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>问题的由来是我在使用Canvas绘制一个圆形进度条时，在绘制出进度条后发现进度条显示的质量很差，整个圆形的周边充斥着毛边，因此寻求一种有效的抗锯齿解决办法。</p>\n<p><img src=\"http://s.songzhj.com/img/20171210/juchi.png\" alt=\"\"></p>\n<h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><p>为了解决锯齿的问题，我们使用一种简单的缩放方式来减小绘制图形的锯齿。<br>该方法有几个关键点：</p>\n<ul>\n<li><p>将canvas元素放入一个固定宽高的容器中，并且正常给canvas一个宽高（通常与外层容器一样即可）</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"m-canvas-container\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">canvas</span> <span class=\"attr\">id</span>=<span class=\"string\">\"canvas\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"200\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"200\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">canvas</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在css中将canvas元素的width设置为100%。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#canvas</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在绘制canvas时，定义一个缩放参数SCALE，将canvas的height和width扩大SCALE倍，后续所有绘制都放大SCALE倍。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">draw</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    canvas.width = SCALE * canvas.width;</span><br><span class=\"line\">    canvas.height = SCALE * canvas.height;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"你可能不知道的React之setState","date":"2017-12-10T08:42:59.000Z","_content":"\nsetState是React中一个最基本的方法，它会将state更新到新的状态并触发页面的重新渲染。最近看了一眼官方文档，才发现我一点都不了解这个常用的方法。\n\n## 平时用的setState\n通常情况下，在使用setState的时候，都是直接将要更新的状态传入。\n```javascript\nthis.setState({\n    a: 'newState'\n});\n```\n讲道理，正常使用的时候这么用是不会遇到什么问题的，但是如果你连续改变了一个state的值，那可能会遇到一些问题，比如这样：\n```javascript\n// this.state初始状态{a: 0}\nfunction f() {\n    this.setState({a: this.state.a + 1});\n    this.setState({a: this.state.a + 1});\n    this.setState({a: this.state.a + 1});\n}\n```\n当上面的函数f执行之后，this.state.a的值是多少呢？结果出乎意料，a的值是1。仔细想想这是有道理的，React并不会每次setState后立即触发更新的过程，如果真的这样的话效率未免会太低了，它会将上面的3次setState攒一波，然后一起setState。所以三次setState中的this.state.a的值都是原来的值（{a: 0}），最后的结果就是1。\n\n## setState能传一个函数\n让我惊讶的是，setState能传一个函数进去，函数有两个参数：第一个参数是当前的state，第二个参数是props；函数最后return回去的对象就会形成新的state。于是上面的过程可以改写成这样：\n```javascript\n// this.state初始状态{a: 0}\nfunction add(state, props) {\n    return {a: state.a + 1};\n}\nfunction f() {\n    this.setState(add);\n    this.setState(add);\n    this.setState(add);\n}\n```\n这种情况下，当f执行后会发现，this.state.a的值是3。这是因为函数式的传参会将每次state的改动记录下来，因此a每次增加都会被正确的记录并最终更新到新的state。\n> 需要注意的是，使用函数式传参的方式，state的值并没有真的改变，同样是攒了一波，等到render函数执行的时候真正的state才会被更新。\n\n## setState还能传一个回调函数\nsetState这个方法还能接受第二个参数，是一个回调函数，它在setState完成是被调用，该回调函数的参数是更新后的state。但是官方并不推荐用这种写法，通常这样的操作都可以在componentDidUpdate中进行。\n\n## 其它\n[setState的官方文档](https://facebook.github.io/react/docs/react-component.html#setstate)","source":"_posts/你可能不知道的React之setState.md","raw":"---\ntitle: 你可能不知道的React之setState\ndate: 2017-12-10 16:42:59\ntags:\n---\n\nsetState是React中一个最基本的方法，它会将state更新到新的状态并触发页面的重新渲染。最近看了一眼官方文档，才发现我一点都不了解这个常用的方法。\n\n## 平时用的setState\n通常情况下，在使用setState的时候，都是直接将要更新的状态传入。\n```javascript\nthis.setState({\n    a: 'newState'\n});\n```\n讲道理，正常使用的时候这么用是不会遇到什么问题的，但是如果你连续改变了一个state的值，那可能会遇到一些问题，比如这样：\n```javascript\n// this.state初始状态{a: 0}\nfunction f() {\n    this.setState({a: this.state.a + 1});\n    this.setState({a: this.state.a + 1});\n    this.setState({a: this.state.a + 1});\n}\n```\n当上面的函数f执行之后，this.state.a的值是多少呢？结果出乎意料，a的值是1。仔细想想这是有道理的，React并不会每次setState后立即触发更新的过程，如果真的这样的话效率未免会太低了，它会将上面的3次setState攒一波，然后一起setState。所以三次setState中的this.state.a的值都是原来的值（{a: 0}），最后的结果就是1。\n\n## setState能传一个函数\n让我惊讶的是，setState能传一个函数进去，函数有两个参数：第一个参数是当前的state，第二个参数是props；函数最后return回去的对象就会形成新的state。于是上面的过程可以改写成这样：\n```javascript\n// this.state初始状态{a: 0}\nfunction add(state, props) {\n    return {a: state.a + 1};\n}\nfunction f() {\n    this.setState(add);\n    this.setState(add);\n    this.setState(add);\n}\n```\n这种情况下，当f执行后会发现，this.state.a的值是3。这是因为函数式的传参会将每次state的改动记录下来，因此a每次增加都会被正确的记录并最终更新到新的state。\n> 需要注意的是，使用函数式传参的方式，state的值并没有真的改变，同样是攒了一波，等到render函数执行的时候真正的state才会被更新。\n\n## setState还能传一个回调函数\nsetState这个方法还能接受第二个参数，是一个回调函数，它在setState完成是被调用，该回调函数的参数是更新后的state。但是官方并不推荐用这种写法，通常这样的操作都可以在componentDidUpdate中进行。\n\n## 其它\n[setState的官方文档](https://facebook.github.io/react/docs/react-component.html#setstate)","slug":"你可能不知道的React之setState","published":1,"updated":"2017-12-10T08:43:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb0ivqih0002jawrdd1u8vzd","content":"<p>setState是React中一个最基本的方法，它会将state更新到新的状态并触发页面的重新渲染。最近看了一眼官方文档，才发现我一点都不了解这个常用的方法。</p>\n<h2 id=\"平时用的setState\"><a href=\"#平时用的setState\" class=\"headerlink\" title=\"平时用的setState\"></a>平时用的setState</h2><p>通常情况下，在使用setState的时候，都是直接将要更新的状态传入。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">    a: <span class=\"string\">'newState'</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>讲道理，正常使用的时候这么用是不会遇到什么问题的，但是如果你连续改变了一个state的值，那可能会遇到一些问题，比如这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// this.state初始状态&#123;a: 0&#125;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">a</span>: <span class=\"keyword\">this</span>.state.a + <span class=\"number\">1</span>&#125;);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">a</span>: <span class=\"keyword\">this</span>.state.a + <span class=\"number\">1</span>&#125;);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">a</span>: <span class=\"keyword\">this</span>.state.a + <span class=\"number\">1</span>&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当上面的函数f执行之后，this.state.a的值是多少呢？结果出乎意料，a的值是1。仔细想想这是有道理的，React并不会每次setState后立即触发更新的过程，如果真的这样的话效率未免会太低了，它会将上面的3次setState攒一波，然后一起setState。所以三次setState中的this.state.a的值都是原来的值（{a: 0}），最后的结果就是1。</p>\n<h2 id=\"setState能传一个函数\"><a href=\"#setState能传一个函数\" class=\"headerlink\" title=\"setState能传一个函数\"></a>setState能传一个函数</h2><p>让我惊讶的是，setState能传一个函数进去，函数有两个参数：第一个参数是当前的state，第二个参数是props；函数最后return回去的对象就会形成新的state。于是上面的过程可以改写成这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// this.state初始状态&#123;a: 0&#125;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">state, props</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;<span class=\"attr\">a</span>: state.a + <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(add);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(add);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(add);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这种情况下，当f执行后会发现，this.state.a的值是3。这是因为函数式的传参会将每次state的改动记录下来，因此a每次增加都会被正确的记录并最终更新到新的state。</p>\n<blockquote>\n<p>需要注意的是，使用函数式传参的方式，state的值并没有真的改变，同样是攒了一波，等到render函数执行的时候真正的state才会被更新。</p>\n</blockquote>\n<h2 id=\"setState还能传一个回调函数\"><a href=\"#setState还能传一个回调函数\" class=\"headerlink\" title=\"setState还能传一个回调函数\"></a>setState还能传一个回调函数</h2><p>setState这个方法还能接受第二个参数，是一个回调函数，它在setState完成是被调用，该回调函数的参数是更新后的state。但是官方并不推荐用这种写法，通常这样的操作都可以在componentDidUpdate中进行。</p>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><p><a href=\"https://facebook.github.io/react/docs/react-component.html#setstate\" target=\"_blank\" rel=\"noopener\">setState的官方文档</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>setState是React中一个最基本的方法，它会将state更新到新的状态并触发页面的重新渲染。最近看了一眼官方文档，才发现我一点都不了解这个常用的方法。</p>\n<h2 id=\"平时用的setState\"><a href=\"#平时用的setState\" class=\"headerlink\" title=\"平时用的setState\"></a>平时用的setState</h2><p>通常情况下，在使用setState的时候，都是直接将要更新的状态传入。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">    a: <span class=\"string\">'newState'</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>讲道理，正常使用的时候这么用是不会遇到什么问题的，但是如果你连续改变了一个state的值，那可能会遇到一些问题，比如这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// this.state初始状态&#123;a: 0&#125;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">a</span>: <span class=\"keyword\">this</span>.state.a + <span class=\"number\">1</span>&#125;);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">a</span>: <span class=\"keyword\">this</span>.state.a + <span class=\"number\">1</span>&#125;);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">a</span>: <span class=\"keyword\">this</span>.state.a + <span class=\"number\">1</span>&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当上面的函数f执行之后，this.state.a的值是多少呢？结果出乎意料，a的值是1。仔细想想这是有道理的，React并不会每次setState后立即触发更新的过程，如果真的这样的话效率未免会太低了，它会将上面的3次setState攒一波，然后一起setState。所以三次setState中的this.state.a的值都是原来的值（{a: 0}），最后的结果就是1。</p>\n<h2 id=\"setState能传一个函数\"><a href=\"#setState能传一个函数\" class=\"headerlink\" title=\"setState能传一个函数\"></a>setState能传一个函数</h2><p>让我惊讶的是，setState能传一个函数进去，函数有两个参数：第一个参数是当前的state，第二个参数是props；函数最后return回去的对象就会形成新的state。于是上面的过程可以改写成这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// this.state初始状态&#123;a: 0&#125;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">state, props</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;<span class=\"attr\">a</span>: state.a + <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(add);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(add);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(add);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这种情况下，当f执行后会发现，this.state.a的值是3。这是因为函数式的传参会将每次state的改动记录下来，因此a每次增加都会被正确的记录并最终更新到新的state。</p>\n<blockquote>\n<p>需要注意的是，使用函数式传参的方式，state的值并没有真的改变，同样是攒了一波，等到render函数执行的时候真正的state才会被更新。</p>\n</blockquote>\n<h2 id=\"setState还能传一个回调函数\"><a href=\"#setState还能传一个回调函数\" class=\"headerlink\" title=\"setState还能传一个回调函数\"></a>setState还能传一个回调函数</h2><p>setState这个方法还能接受第二个参数，是一个回调函数，它在setState完成是被调用，该回调函数的参数是更新后的state。但是官方并不推荐用这种写法，通常这样的操作都可以在componentDidUpdate中进行。</p>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><p><a href=\"https://facebook.github.io/react/docs/react-component.html#setstate\" target=\"_blank\" rel=\"noopener\">setState的官方文档</a></p>\n"},{"title":"使用VPS搭建VPN – PPTP","date":"2016-10-03T08:16:24.000Z","_content":"<span style=\"color: #a39d9d;\">最近闲着没事，自己租了个VPS顺手搭了个VPN出来。</span>\n\n首先去随便买个境外的VPS，我这边买了个香港的，还算便宜。\n\n以下过程全部在SSH远程连接下操作。\n\n<hr />\n\n<h2>1、 安装pptpd</h2>\n\n<pre class=\"lang:sh decode:true\">$ apt-get install pptpd</pre>\n\n<h2>2、 配置pptpd</h2>\n\n编辑pptpd.conf文件，设置localip和remoteip\n\n<pre class=\"lang:sh decode:true\">$ vim /etc/pptpd.conf</pre>\n\n添加localip和remoteip，将其设置为下面的形式（其中VPS_IP为你的VPS公网ip）\n\n<pre class=\"nums:false lang:default decode:true\">localip VPS_IP\nremoteip 10.100.0.2-100</pre>\n\n<div class=\"line\">修改dns设置</div>\n\n<div class=\"line\">\n<pre class=\"lang:sh decode:true\" style=\"padding-left: 30px;\">$ vim /etc/ppp/pptpd-options</pre>\n</div>\n\n查找到ms-dns，配置dns，这里以google的dns（8.8.8.8）为例（我配置成了香港沙田的dns）\n\n<pre class=\"nums:false lang:default decode:true\">ms-dns 8.8.8.8\nms-dns 8.8.4.4</pre>\n\n<div class=\"line\">设置VPN的账号和密码</div>\n\n<div class=\"line\">编辑chap-secrets文件</div>\n\n<div class=\"line\">\n<pre class=\"lang:sh decode:true\">$ vim /etc/ppp/chap-secrets</pre>\n</div>\n\n在其中加入如下格式的配置（每行对应一个VPN账号）\n\n<span class=\"lang:default decode:true crayon-inline\">用户名 pptpd 密码 *</span>\n\n<h2>3、 启动pptpd</h2>\n\n<pre class=\"lang:sh decode:true\">$ /etc/init.d/pptpd restart</pre>\n\n<h2>4、 开启ipv4转发</h2>\n\n编辑sysctl.conf文件\n\n<pre class=\"lang:sh decode:true\">$ vim /etc/sysctl.conf</pre>\n\n将<span class=\"lang:sh decode:true crayon-inline\">net.ipv4.ip_forward=1</span> <code>的注释去掉，退出并保存</code>\n\n运行<span class=\"lang:sh decode:true crayon-inline \">sysctl -p</span> <code>使</code>更改生效\n\n<h2>5、 配置iptables</h2>\n\n<pre class=\"lang:sh decode:true\">$ iptables -t nat -A POSTROUTING -s 10.100.0.0/24 -o eth0 -j MASQUERADE\n$ iptables -A FORWARD -s 10.100.0.0/24 -p tcp -m tcp --tcp-flags SYN,RST SYN -j TCPMSS --set-mss 1430\n$ iptables -t nat -A POSTROUTING -s 10.100.0.0/24 -j SNAT --to-source VPS_IP\n$ iptables-save &gt; /etc/iptables-rules</pre>\n\n编辑网卡文件<span class=\"lang:sh decode:true crayon-inline \">$ vim /etc/network/interfaces</span>\n\n在其末尾加入<span class=\"lang:sh decode:true crayon-inline \">pre-up iptables-restore &lt; /etc/iptables-rules</span>\n\n配置iptables持久化\n\n<pre class=\"lang:sh decode:true\">$ apt-get install iptables-persistent\n$ service iptables-persistent start</pre>\n\n<h2>6、 其它</h2>\n\n<ol>\n    <li>如果不能VPN连接不上，可以尝试完全卸载iptables重新配置。</li>\n    <li>由于一般网卡的MTU都是1500，因此VPN的MTU值可以尝试从1024逐渐增大，文中的1430是当前最大值。</li>\n</ol>","source":"_posts/使用VPS搭建VPN-–-PPTP.md","raw":"---\ntitle: 使用VPS搭建VPN – PPTP\ndate: 2016-10-03 16:16:24\ntags:\n---\n<span style=\"color: #a39d9d;\">最近闲着没事，自己租了个VPS顺手搭了个VPN出来。</span>\n\n首先去随便买个境外的VPS，我这边买了个香港的，还算便宜。\n\n以下过程全部在SSH远程连接下操作。\n\n<hr />\n\n<h2>1、 安装pptpd</h2>\n\n<pre class=\"lang:sh decode:true\">$ apt-get install pptpd</pre>\n\n<h2>2、 配置pptpd</h2>\n\n编辑pptpd.conf文件，设置localip和remoteip\n\n<pre class=\"lang:sh decode:true\">$ vim /etc/pptpd.conf</pre>\n\n添加localip和remoteip，将其设置为下面的形式（其中VPS_IP为你的VPS公网ip）\n\n<pre class=\"nums:false lang:default decode:true\">localip VPS_IP\nremoteip 10.100.0.2-100</pre>\n\n<div class=\"line\">修改dns设置</div>\n\n<div class=\"line\">\n<pre class=\"lang:sh decode:true\" style=\"padding-left: 30px;\">$ vim /etc/ppp/pptpd-options</pre>\n</div>\n\n查找到ms-dns，配置dns，这里以google的dns（8.8.8.8）为例（我配置成了香港沙田的dns）\n\n<pre class=\"nums:false lang:default decode:true\">ms-dns 8.8.8.8\nms-dns 8.8.4.4</pre>\n\n<div class=\"line\">设置VPN的账号和密码</div>\n\n<div class=\"line\">编辑chap-secrets文件</div>\n\n<div class=\"line\">\n<pre class=\"lang:sh decode:true\">$ vim /etc/ppp/chap-secrets</pre>\n</div>\n\n在其中加入如下格式的配置（每行对应一个VPN账号）\n\n<span class=\"lang:default decode:true crayon-inline\">用户名 pptpd 密码 *</span>\n\n<h2>3、 启动pptpd</h2>\n\n<pre class=\"lang:sh decode:true\">$ /etc/init.d/pptpd restart</pre>\n\n<h2>4、 开启ipv4转发</h2>\n\n编辑sysctl.conf文件\n\n<pre class=\"lang:sh decode:true\">$ vim /etc/sysctl.conf</pre>\n\n将<span class=\"lang:sh decode:true crayon-inline\">net.ipv4.ip_forward=1</span> <code>的注释去掉，退出并保存</code>\n\n运行<span class=\"lang:sh decode:true crayon-inline \">sysctl -p</span> <code>使</code>更改生效\n\n<h2>5、 配置iptables</h2>\n\n<pre class=\"lang:sh decode:true\">$ iptables -t nat -A POSTROUTING -s 10.100.0.0/24 -o eth0 -j MASQUERADE\n$ iptables -A FORWARD -s 10.100.0.0/24 -p tcp -m tcp --tcp-flags SYN,RST SYN -j TCPMSS --set-mss 1430\n$ iptables -t nat -A POSTROUTING -s 10.100.0.0/24 -j SNAT --to-source VPS_IP\n$ iptables-save &gt; /etc/iptables-rules</pre>\n\n编辑网卡文件<span class=\"lang:sh decode:true crayon-inline \">$ vim /etc/network/interfaces</span>\n\n在其末尾加入<span class=\"lang:sh decode:true crayon-inline \">pre-up iptables-restore &lt; /etc/iptables-rules</span>\n\n配置iptables持久化\n\n<pre class=\"lang:sh decode:true\">$ apt-get install iptables-persistent\n$ service iptables-persistent start</pre>\n\n<h2>6、 其它</h2>\n\n<ol>\n    <li>如果不能VPN连接不上，可以尝试完全卸载iptables重新配置。</li>\n    <li>由于一般网卡的MTU都是1500，因此VPN的MTU值可以尝试从1024逐渐增大，文中的1430是当前最大值。</li>\n</ol>","slug":"使用VPS搭建VPN-–-PPTP","published":1,"updated":"2017-12-10T08:40:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb0ivqir0003jawrh835lr0t","content":"<p><span style=\"color: #a39d9d;\">最近闲着没事，自己租了个VPS顺手搭了个VPN出来。</span></p>\n<p>首先去随便买个境外的VPS，我这边买了个香港的，还算便宜。</p>\n<p>以下过程全部在SSH远程连接下操作。</p>\n<hr>\n\n<h2>1、 安装pptpd</h2>\n\n<pre class=\"lang:sh decode:true\">$ apt-get install pptpd</pre>\n\n<h2>2、 配置pptpd</h2>\n\n<p>编辑pptpd.conf文件，设置localip和remoteip</p>\n<pre class=\"lang:sh decode:true\">$ vim /etc/pptpd.conf</pre>\n\n<p>添加localip和remoteip，将其设置为下面的形式（其中VPS_IP为你的VPS公网ip）</p>\n<pre class=\"nums:false lang:default decode:true\">localip VPS_IP\nremoteip 10.100.0.2-100</pre>\n\n<div class=\"line\">修改dns设置</div>\n\n<div class=\"line\"><br><pre class=\"lang:sh decode:true\" style=\"padding-left: 30px;\">$ vim /etc/ppp/pptpd-options</pre><br></div>\n\n<p>查找到ms-dns，配置dns，这里以google的dns（8.8.8.8）为例（我配置成了香港沙田的dns）</p>\n<pre class=\"nums:false lang:default decode:true\">ms-dns 8.8.8.8\nms-dns 8.8.4.4</pre>\n\n<div class=\"line\">设置VPN的账号和密码</div>\n\n<div class=\"line\">编辑chap-secrets文件</div>\n\n<div class=\"line\"><br><pre class=\"lang:sh decode:true\">$ vim /etc/ppp/chap-secrets</pre><br></div>\n\n<p>在其中加入如下格式的配置（每行对应一个VPN账号）</p>\n<p><span class=\"lang:default decode:true crayon-inline\">用户名 pptpd 密码 *</span></p>\n<h2>3、 启动pptpd</h2>\n\n<pre class=\"lang:sh decode:true\">$ /etc/init.d/pptpd restart</pre>\n\n<h2>4、 开启ipv4转发</h2>\n\n<p>编辑sysctl.conf文件</p>\n<pre class=\"lang:sh decode:true\">$ vim /etc/sysctl.conf</pre>\n\n<p>将<span class=\"lang:sh decode:true crayon-inline\">net.ipv4.ip_forward=1</span> <code>的注释去掉，退出并保存</code></p>\n<p>运行<span class=\"lang:sh decode:true crayon-inline \">sysctl -p</span> <code>使</code>更改生效</p>\n<h2>5、 配置iptables</h2>\n\n<pre class=\"lang:sh decode:true\">$ iptables -t nat -A POSTROUTING -s 10.100.0.0/24 -o eth0 -j MASQUERADE\n$ iptables -A FORWARD -s 10.100.0.0/24 -p tcp -m tcp --tcp-flags SYN,RST SYN -j TCPMSS --set-mss 1430\n$ iptables -t nat -A POSTROUTING -s 10.100.0.0/24 -j SNAT --to-source VPS_IP\n$ iptables-save &gt; /etc/iptables-rules</pre>\n\n<p>编辑网卡文件<span class=\"lang:sh decode:true crayon-inline \">$ vim /etc/network/interfaces</span></p>\n<p>在其末尾加入<span class=\"lang:sh decode:true crayon-inline \">pre-up iptables-restore &lt; /etc/iptables-rules</span></p>\n<p>配置iptables持久化</p>\n<pre class=\"lang:sh decode:true\">$ apt-get install iptables-persistent\n$ service iptables-persistent start</pre>\n\n<h2>6、 其它</h2>\n\n<ol><br>    <li>如果不能VPN连接不上，可以尝试完全卸载iptables重新配置。</li><br>    <li>由于一般网卡的MTU都是1500，因此VPN的MTU值可以尝试从1024逐渐增大，文中的1430是当前最大值。</li><br></ol>","site":{"data":{}},"excerpt":"","more":"<p><span style=\"color: #a39d9d;\">最近闲着没事，自己租了个VPS顺手搭了个VPN出来。</span></p>\n<p>首先去随便买个境外的VPS，我这边买了个香港的，还算便宜。</p>\n<p>以下过程全部在SSH远程连接下操作。</p>\n<hr>\n\n<h2>1、 安装pptpd</h2>\n\n<pre class=\"lang:sh decode:true\">$ apt-get install pptpd</pre>\n\n<h2>2、 配置pptpd</h2>\n\n<p>编辑pptpd.conf文件，设置localip和remoteip</p>\n<pre class=\"lang:sh decode:true\">$ vim /etc/pptpd.conf</pre>\n\n<p>添加localip和remoteip，将其设置为下面的形式（其中VPS_IP为你的VPS公网ip）</p>\n<pre class=\"nums:false lang:default decode:true\">localip VPS_IP\nremoteip 10.100.0.2-100</pre>\n\n<div class=\"line\">修改dns设置</div>\n\n<div class=\"line\"><br><pre class=\"lang:sh decode:true\" style=\"padding-left: 30px;\">$ vim /etc/ppp/pptpd-options</pre><br></div>\n\n<p>查找到ms-dns，配置dns，这里以google的dns（8.8.8.8）为例（我配置成了香港沙田的dns）</p>\n<pre class=\"nums:false lang:default decode:true\">ms-dns 8.8.8.8\nms-dns 8.8.4.4</pre>\n\n<div class=\"line\">设置VPN的账号和密码</div>\n\n<div class=\"line\">编辑chap-secrets文件</div>\n\n<div class=\"line\"><br><pre class=\"lang:sh decode:true\">$ vim /etc/ppp/chap-secrets</pre><br></div>\n\n<p>在其中加入如下格式的配置（每行对应一个VPN账号）</p>\n<p><span class=\"lang:default decode:true crayon-inline\">用户名 pptpd 密码 *</span></p>\n<h2>3、 启动pptpd</h2>\n\n<pre class=\"lang:sh decode:true\">$ /etc/init.d/pptpd restart</pre>\n\n<h2>4、 开启ipv4转发</h2>\n\n<p>编辑sysctl.conf文件</p>\n<pre class=\"lang:sh decode:true\">$ vim /etc/sysctl.conf</pre>\n\n<p>将<span class=\"lang:sh decode:true crayon-inline\">net.ipv4.ip_forward=1</span> <code>的注释去掉，退出并保存</code></p>\n<p>运行<span class=\"lang:sh decode:true crayon-inline \">sysctl -p</span> <code>使</code>更改生效</p>\n<h2>5、 配置iptables</h2>\n\n<pre class=\"lang:sh decode:true\">$ iptables -t nat -A POSTROUTING -s 10.100.0.0/24 -o eth0 -j MASQUERADE\n$ iptables -A FORWARD -s 10.100.0.0/24 -p tcp -m tcp --tcp-flags SYN,RST SYN -j TCPMSS --set-mss 1430\n$ iptables -t nat -A POSTROUTING -s 10.100.0.0/24 -j SNAT --to-source VPS_IP\n$ iptables-save &gt; /etc/iptables-rules</pre>\n\n<p>编辑网卡文件<span class=\"lang:sh decode:true crayon-inline \">$ vim /etc/network/interfaces</span></p>\n<p>在其末尾加入<span class=\"lang:sh decode:true crayon-inline \">pre-up iptables-restore &lt; /etc/iptables-rules</span></p>\n<p>配置iptables持久化</p>\n<pre class=\"lang:sh decode:true\">$ apt-get install iptables-persistent\n$ service iptables-persistent start</pre>\n\n<h2>6、 其它</h2>\n\n<ol><br>    <li>如果不能VPN连接不上，可以尝试完全卸载iptables重新配置。</li><br>    <li>由于一般网卡的MTU都是1500，因此VPN的MTU值可以尝试从1024逐渐增大，文中的1430是当前最大值。</li><br></ol>"},{"title":"浅谈js异步","date":"2017-03-10T08:31:54.000Z","_content":"\nJavascript语言的执行环境是\"单线程\",如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。\n\n- 好处：实现起来比较简单，执行环境相对单纯；\n- 坏处：只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。\n- 解决办法：Javascript语言将任务的执行模式分成两种：同步和异步。\n\n## js中异步的几种方式\n\n### 1. callback\n异步编程最基本的方法。\n```javascript\nfunction f1(callback) {\n    setTimeout(function() {\n        callback();\n    }, 2000);\n}\n```\n缺点：耦合度高，不利于代码维护；而且每个任务只能指定一个回调函数。\n\n### 2. event\n使用事件驱动的模式。\n```javascript\nf1.on('wtf', f2);\n\nfunction f1() {\n    setTimeout(function() {\n        f1.trigger('wtf');\n    }, 2000);\n}\n```\n能够去耦合，但是整个程序都变成了事件驱动，运行流程会变得很不清晰，不符合人脑习惯（顺序）。\n\n### 3. promise\nCommongJS提出的规范，现在已经被纳入ES6标准。目的是为异步编程提供统一接口。\n```javascript\nfunction f1(...args) {\n    return new Promise(function(resolve, reject) {\n        //do something\n        ajax.get.apply(ajax, args.concat([function(data) {\n            if (data.status == 1) {\n                resolve(data);\n            } else {\n                reject(data);\n            }\n        }]));\n    });\n}\n\nf1('/flight/air', {from: '北京', arrive: '上海'})\n.then(f2)\n.catch(f3);\n```\nPromise方法和它的字面意思一样，保证了代码先后的执行顺序。以往的回调可以使用Promise封装，封装后的代码写起来是顺序执行的，符合人的思考方式，也便于阅读和维护。\n\n另外Promise对象同样可以返回一个新的Promise对象，能够采用链式写法，摆脱了callback hell。\n\n### 4. co\nco是一个异步模块，它基于ES6的generator和yield，让我们能够用同步的形式编写异步代码。\n```javascript\nco(function *() {\n    var data = yield $.get('/flight/data');\n    console.log(data);\n    var user = yield $.get('/flight/user');\n    console.log(user);\n    var air = yield $.get('/flight/air');\n    console.log(air);\n});\n```\ngenerator本来就是一个迭代器生成器，但是被[TJ](http://tjholowaychuk.com/)这个大神给创造性的拿来解决异步流程问题了，膜。\n> TJ Holowaychuk，程序员兼艺术家，Koa、Co、Express、jade、mocha、node-canvas、commander.js等知名开源项目的创建和贡献者。\n\n### 5. async\nasync/await其实和co是类似的东西，可以说是将co的方案纳入了ES7标准，类似于一个语法糖。\n```javascript\n//node version at least 7.0.0\nconst f = () => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(123);\n    }, 2000);\n  });\n};\n\nconst testAsync = async () => {\n  const t = await f();\n  console.log(t);\n};\n\ntestAsync();\n```\nasync/await被称作是异步编程终极解决方案，他让整个流程真正看起来像是按照代码顺序同步执行，而且还有其它的优点。\n\n-------\n\n## co\nco模块的简单思路：\n```javascript\nfunction co(gen) {\n    var it = gen();\n    var ret = it.next();\n    ret.value.then(function(res) {\n        it.next(res);\n    });\n}\n```\ngenerator函数体可以停在yield语句处，直到下一次执行next()。co模块的思路就是利用这个特性，将异步操作跟在yield后面，当异步操作完成并返回结果后，再触发下一次next()。\n\n> 跟在yield后面的异步操作需要遵循一定的规范：**promise**和thunk。\n\n## async\nasync/await可以说是对于异步编程比较简单好用的方案，对于不是很复杂的用例下已经够用了。\n> await等待的是一个表达式，这个表达式的计算结果是 Promise对象或者其它值。如果它等到的不是一个Promise对象，那await表达式的运算结果就是它等到的东西；如果它等到的是一个Promise对象，await就忙起来了，它会阻塞后面的代码，等着Promise对象resolve，然后得到resolve的值，作为await表达式的运算结果。\n\n> 因为async函数返回一个Promise对象，所以await可以用于等待一个async函数的返回值。\n\n#### async/await的优势？\n- 处理then链\n- 解决Promise参数传递过于麻烦的问题\n\n**Demo**：对于一个业务，分三个步骤(step1,step2,step3)，每个步骤都是异步的，并且依赖于上一个步骤的结果。\n```javascript\nfunction takeLongTime(n) {\n    return new Promise(resolve => {\n        setTimeout(() => resolve(n + 200), n);\n    });\n}\n\nfunction step1(n) {\n    console.log(`step1 with ${n}`);\n    return takeLongTime(n);\n}\n\nfunction step2(n) {\n    console.log(`step2 with ${n}`);\n    return takeLongTime(n);\n}\n\nfunction step3(n) {\n    console.log(`step3 with ${n}`);\n    return takeLongTime(n);\n}\n```\n\n**promise**\n```javascript\nfunction doIt() {\n    console.time(\"doIt\");\n    const time1 = 300;\n    step1(time1)\n        .then(time2 => step2(time2))\n        .then(time3 => step3(time3))\n        .then(result => {\n            console.log(`result is ${result}`);\n            console.timeEnd(\"doIt\");\n        });\n}\n\ndoIt();\n```\n\n**async**\n```javascript\nasync function doIt() {\n    console.time(\"doIt\");\n    const time1 = 300;\n    const time2 = await step1(time1);\n    const time3 = await step2(time2);\n    const result = await step3(time3);\n    console.log(`result is ${result}`);\n    console.timeEnd(\"doIt\");\n}\n\ndoIt();\n```\n\n**Demo**：每一步都需要之前所有步骤的结果。\n```javascript\nfunction takeLongTime(n) {\n    return new Promise(resolve => {\n        setTimeout(() => resolve(n + 200), n);\n    });\n}\n\nfunction step1(n) {\n    console.log(`step1 with ${n}`);\n    return takeLongTime(n);\n}\n\nfunction step2(m, n) {\n    console.log(`step2 with ${m} and ${n}`);\n    return takeLongTime(m + n);\n}\n\nfunction step3(k, m, n) {\n    console.log(`step3 with ${k}, ${m} and ${n}`);\n    return takeLongTime(k + m + n);\n}\n```\n\n**async**\n```javascript\nasync function doIt() {\n    console.time(\"doIt\");\n    const time1 = 300;\n    const time2 = await step1(time1);\n    const time3 = await step2(time1, time2);\n    const result = await step3(time1, time2, time3);\n    console.log(`result is ${result}`);\n    console.timeEnd(\"doIt\");\n}\n\ndoIt();\n```\n\n**promise**\n```javascript\nfunction doIt() {\n    console.time(\"doIt\");\n    const time1 = 300;\n    step1(time1)\n        .then(time2 => {\n            return step2(time1, time2)\n                .then(time3 => [time1, time2, time3]);\n        })\n        .then(times => {\n            const [time1, time2, time3] = times;\n            return step3(time1, time2, time3);\n        })\n        .then(result => {\n            console.log(`result is ${result}`);\n            console.timeEnd(\"doIt\");\n        });\n}\ndoIt();\n```\n\n\n\n## 其它\n- async和co都是可以使用try/catch的。\n- await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try/catch代码块中。\n- thunk：不讲了。","source":"_posts/浅谈js异步.md","raw":"---\ntitle: 浅谈js异步\ndate: 2017-03-10 16:31:54\ntags:\n---\n\nJavascript语言的执行环境是\"单线程\",如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。\n\n- 好处：实现起来比较简单，执行环境相对单纯；\n- 坏处：只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。\n- 解决办法：Javascript语言将任务的执行模式分成两种：同步和异步。\n\n## js中异步的几种方式\n\n### 1. callback\n异步编程最基本的方法。\n```javascript\nfunction f1(callback) {\n    setTimeout(function() {\n        callback();\n    }, 2000);\n}\n```\n缺点：耦合度高，不利于代码维护；而且每个任务只能指定一个回调函数。\n\n### 2. event\n使用事件驱动的模式。\n```javascript\nf1.on('wtf', f2);\n\nfunction f1() {\n    setTimeout(function() {\n        f1.trigger('wtf');\n    }, 2000);\n}\n```\n能够去耦合，但是整个程序都变成了事件驱动，运行流程会变得很不清晰，不符合人脑习惯（顺序）。\n\n### 3. promise\nCommongJS提出的规范，现在已经被纳入ES6标准。目的是为异步编程提供统一接口。\n```javascript\nfunction f1(...args) {\n    return new Promise(function(resolve, reject) {\n        //do something\n        ajax.get.apply(ajax, args.concat([function(data) {\n            if (data.status == 1) {\n                resolve(data);\n            } else {\n                reject(data);\n            }\n        }]));\n    });\n}\n\nf1('/flight/air', {from: '北京', arrive: '上海'})\n.then(f2)\n.catch(f3);\n```\nPromise方法和它的字面意思一样，保证了代码先后的执行顺序。以往的回调可以使用Promise封装，封装后的代码写起来是顺序执行的，符合人的思考方式，也便于阅读和维护。\n\n另外Promise对象同样可以返回一个新的Promise对象，能够采用链式写法，摆脱了callback hell。\n\n### 4. co\nco是一个异步模块，它基于ES6的generator和yield，让我们能够用同步的形式编写异步代码。\n```javascript\nco(function *() {\n    var data = yield $.get('/flight/data');\n    console.log(data);\n    var user = yield $.get('/flight/user');\n    console.log(user);\n    var air = yield $.get('/flight/air');\n    console.log(air);\n});\n```\ngenerator本来就是一个迭代器生成器，但是被[TJ](http://tjholowaychuk.com/)这个大神给创造性的拿来解决异步流程问题了，膜。\n> TJ Holowaychuk，程序员兼艺术家，Koa、Co、Express、jade、mocha、node-canvas、commander.js等知名开源项目的创建和贡献者。\n\n### 5. async\nasync/await其实和co是类似的东西，可以说是将co的方案纳入了ES7标准，类似于一个语法糖。\n```javascript\n//node version at least 7.0.0\nconst f = () => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(123);\n    }, 2000);\n  });\n};\n\nconst testAsync = async () => {\n  const t = await f();\n  console.log(t);\n};\n\ntestAsync();\n```\nasync/await被称作是异步编程终极解决方案，他让整个流程真正看起来像是按照代码顺序同步执行，而且还有其它的优点。\n\n-------\n\n## co\nco模块的简单思路：\n```javascript\nfunction co(gen) {\n    var it = gen();\n    var ret = it.next();\n    ret.value.then(function(res) {\n        it.next(res);\n    });\n}\n```\ngenerator函数体可以停在yield语句处，直到下一次执行next()。co模块的思路就是利用这个特性，将异步操作跟在yield后面，当异步操作完成并返回结果后，再触发下一次next()。\n\n> 跟在yield后面的异步操作需要遵循一定的规范：**promise**和thunk。\n\n## async\nasync/await可以说是对于异步编程比较简单好用的方案，对于不是很复杂的用例下已经够用了。\n> await等待的是一个表达式，这个表达式的计算结果是 Promise对象或者其它值。如果它等到的不是一个Promise对象，那await表达式的运算结果就是它等到的东西；如果它等到的是一个Promise对象，await就忙起来了，它会阻塞后面的代码，等着Promise对象resolve，然后得到resolve的值，作为await表达式的运算结果。\n\n> 因为async函数返回一个Promise对象，所以await可以用于等待一个async函数的返回值。\n\n#### async/await的优势？\n- 处理then链\n- 解决Promise参数传递过于麻烦的问题\n\n**Demo**：对于一个业务，分三个步骤(step1,step2,step3)，每个步骤都是异步的，并且依赖于上一个步骤的结果。\n```javascript\nfunction takeLongTime(n) {\n    return new Promise(resolve => {\n        setTimeout(() => resolve(n + 200), n);\n    });\n}\n\nfunction step1(n) {\n    console.log(`step1 with ${n}`);\n    return takeLongTime(n);\n}\n\nfunction step2(n) {\n    console.log(`step2 with ${n}`);\n    return takeLongTime(n);\n}\n\nfunction step3(n) {\n    console.log(`step3 with ${n}`);\n    return takeLongTime(n);\n}\n```\n\n**promise**\n```javascript\nfunction doIt() {\n    console.time(\"doIt\");\n    const time1 = 300;\n    step1(time1)\n        .then(time2 => step2(time2))\n        .then(time3 => step3(time3))\n        .then(result => {\n            console.log(`result is ${result}`);\n            console.timeEnd(\"doIt\");\n        });\n}\n\ndoIt();\n```\n\n**async**\n```javascript\nasync function doIt() {\n    console.time(\"doIt\");\n    const time1 = 300;\n    const time2 = await step1(time1);\n    const time3 = await step2(time2);\n    const result = await step3(time3);\n    console.log(`result is ${result}`);\n    console.timeEnd(\"doIt\");\n}\n\ndoIt();\n```\n\n**Demo**：每一步都需要之前所有步骤的结果。\n```javascript\nfunction takeLongTime(n) {\n    return new Promise(resolve => {\n        setTimeout(() => resolve(n + 200), n);\n    });\n}\n\nfunction step1(n) {\n    console.log(`step1 with ${n}`);\n    return takeLongTime(n);\n}\n\nfunction step2(m, n) {\n    console.log(`step2 with ${m} and ${n}`);\n    return takeLongTime(m + n);\n}\n\nfunction step3(k, m, n) {\n    console.log(`step3 with ${k}, ${m} and ${n}`);\n    return takeLongTime(k + m + n);\n}\n```\n\n**async**\n```javascript\nasync function doIt() {\n    console.time(\"doIt\");\n    const time1 = 300;\n    const time2 = await step1(time1);\n    const time3 = await step2(time1, time2);\n    const result = await step3(time1, time2, time3);\n    console.log(`result is ${result}`);\n    console.timeEnd(\"doIt\");\n}\n\ndoIt();\n```\n\n**promise**\n```javascript\nfunction doIt() {\n    console.time(\"doIt\");\n    const time1 = 300;\n    step1(time1)\n        .then(time2 => {\n            return step2(time1, time2)\n                .then(time3 => [time1, time2, time3]);\n        })\n        .then(times => {\n            const [time1, time2, time3] = times;\n            return step3(time1, time2, time3);\n        })\n        .then(result => {\n            console.log(`result is ${result}`);\n            console.timeEnd(\"doIt\");\n        });\n}\ndoIt();\n```\n\n\n\n## 其它\n- async和co都是可以使用try/catch的。\n- await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try/catch代码块中。\n- thunk：不讲了。","slug":"浅谈js异步","published":1,"updated":"2017-12-10T08:36:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb0ivqiu0004jawrcjfkihi8","content":"<p>Javascript语言的执行环境是”单线程”,如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。</p>\n<ul>\n<li>好处：实现起来比较简单，执行环境相对单纯；</li>\n<li>坏处：只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。</li>\n<li>解决办法：Javascript语言将任务的执行模式分成两种：同步和异步。</li>\n</ul>\n<h2 id=\"js中异步的几种方式\"><a href=\"#js中异步的几种方式\" class=\"headerlink\" title=\"js中异步的几种方式\"></a>js中异步的几种方式</h2><h3 id=\"1-callback\"><a href=\"#1-callback\" class=\"headerlink\" title=\"1. callback\"></a>1. callback</h3><p>异步编程最基本的方法。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        callback();</span><br><span class=\"line\">    &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>缺点：耦合度高，不利于代码维护；而且每个任务只能指定一个回调函数。</p>\n<h3 id=\"2-event\"><a href=\"#2-event\" class=\"headerlink\" title=\"2. event\"></a>2. event</h3><p>使用事件驱动的模式。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1.on(<span class=\"string\">'wtf'</span>, f2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        f1.trigger(<span class=\"string\">'wtf'</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>能够去耦合，但是整个程序都变成了事件驱动，运行流程会变得很不清晰，不符合人脑习惯（顺序）。</p>\n<h3 id=\"3-promise\"><a href=\"#3-promise\" class=\"headerlink\" title=\"3. promise\"></a>3. promise</h3><p>CommongJS提出的规范，现在已经被纳入ES6标准。目的是为异步编程提供统一接口。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//do something</span></span><br><span class=\"line\">        ajax.get.apply(ajax, args.concat([<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (data.status == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                resolve(data);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                reject(data);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;]));</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f1(<span class=\"string\">'/flight/air'</span>, &#123;<span class=\"attr\">from</span>: <span class=\"string\">'北京'</span>, <span class=\"attr\">arrive</span>: <span class=\"string\">'上海'</span>&#125;)</span><br><span class=\"line\">.then(f2)</span><br><span class=\"line\">.catch(f3);</span><br></pre></td></tr></table></figure></p>\n<p>Promise方法和它的字面意思一样，保证了代码先后的执行顺序。以往的回调可以使用Promise封装，封装后的代码写起来是顺序执行的，符合人的思考方式，也便于阅读和维护。</p>\n<p>另外Promise对象同样可以返回一个新的Promise对象，能够采用链式写法，摆脱了callback hell。</p>\n<h3 id=\"4-co\"><a href=\"#4-co\" class=\"headerlink\" title=\"4. co\"></a>4. co</h3><p>co是一个异步模块，它基于ES6的generator和yield，让我们能够用同步的形式编写异步代码。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">co(<span class=\"function\"><span class=\"keyword\">function</span> *(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> data = <span class=\"keyword\">yield</span> $.get(<span class=\"string\">'/flight/data'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> user = <span class=\"keyword\">yield</span> $.get(<span class=\"string\">'/flight/user'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(user);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> air = <span class=\"keyword\">yield</span> $.get(<span class=\"string\">'/flight/air'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(air);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>generator本来就是一个迭代器生成器，但是被<a href=\"http://tjholowaychuk.com/\" target=\"_blank\" rel=\"noopener\">TJ</a>这个大神给创造性的拿来解决异步流程问题了，膜。</p>\n<blockquote>\n<p>TJ Holowaychuk，程序员兼艺术家，Koa、Co、Express、jade、mocha、node-canvas、commander.js等知名开源项目的创建和贡献者。</p>\n</blockquote>\n<h3 id=\"5-async\"><a href=\"#5-async\" class=\"headerlink\" title=\"5. async\"></a>5. async</h3><p>async/await其实和co是类似的东西，可以说是将co的方案纳入了ES7标准，类似于一个语法糖。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//node version at least 7.0.0</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      resolve(<span class=\"number\">123</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> testAsync = <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> t = <span class=\"keyword\">await</span> f();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(t);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">testAsync();</span><br></pre></td></tr></table></figure></p>\n<p>async/await被称作是异步编程终极解决方案，他让整个流程真正看起来像是按照代码顺序同步执行，而且还有其它的优点。</p>\n<hr>\n<h2 id=\"co\"><a href=\"#co\" class=\"headerlink\" title=\"co\"></a>co</h2><p>co模块的简单思路：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">co</span>(<span class=\"params\">gen</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> it = gen();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ret = it.next();</span><br><span class=\"line\">    ret.value.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">        it.next(res);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>generator函数体可以停在yield语句处，直到下一次执行next()。co模块的思路就是利用这个特性，将异步操作跟在yield后面，当异步操作完成并返回结果后，再触发下一次next()。</p>\n<blockquote>\n<p>跟在yield后面的异步操作需要遵循一定的规范：<strong>promise</strong>和thunk。</p>\n</blockquote>\n<h2 id=\"async\"><a href=\"#async\" class=\"headerlink\" title=\"async\"></a>async</h2><p>async/await可以说是对于异步编程比较简单好用的方案，对于不是很复杂的用例下已经够用了。</p>\n<blockquote>\n<p>await等待的是一个表达式，这个表达式的计算结果是 Promise对象或者其它值。如果它等到的不是一个Promise对象，那await表达式的运算结果就是它等到的东西；如果它等到的是一个Promise对象，await就忙起来了，它会阻塞后面的代码，等着Promise对象resolve，然后得到resolve的值，作为await表达式的运算结果。</p>\n<p>因为async函数返回一个Promise对象，所以await可以用于等待一个async函数的返回值。</p>\n</blockquote>\n<h4 id=\"async-await的优势？\"><a href=\"#async-await的优势？\" class=\"headerlink\" title=\"async/await的优势？\"></a>async/await的优势？</h4><ul>\n<li>处理then链</li>\n<li>解决Promise参数传递过于麻烦的问题</li>\n</ul>\n<p><strong>Demo</strong>：对于一个业务，分三个步骤(step1,step2,step3)，每个步骤都是异步的，并且依赖于上一个步骤的结果。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">takeLongTime</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve(n + <span class=\"number\">200</span>), n);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step1</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`step1 with <span class=\"subst\">$&#123;n&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> takeLongTime(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step2</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`step2 with <span class=\"subst\">$&#123;n&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> takeLongTime(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step3</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`step3 with <span class=\"subst\">$&#123;n&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> takeLongTime(n);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>promise</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doIt</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">\"doIt\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> time1 = <span class=\"number\">300</span>;</span><br><span class=\"line\">    step1(time1)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">time2</span> =&gt;</span> step2(time2))</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">time3</span> =&gt;</span> step3(time3))</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">`result is <span class=\"subst\">$&#123;result&#125;</span>`</span>);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">\"doIt\"</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">doIt();</span><br></pre></td></tr></table></figure></p>\n<p><strong>async</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doIt</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">\"doIt\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> time1 = <span class=\"number\">300</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> time2 = <span class=\"keyword\">await</span> step1(time1);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> time3 = <span class=\"keyword\">await</span> step2(time2);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> step3(time3);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`result is <span class=\"subst\">$&#123;result&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">\"doIt\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">doIt();</span><br></pre></td></tr></table></figure></p>\n<p><strong>Demo</strong>：每一步都需要之前所有步骤的结果。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">takeLongTime</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve(n + <span class=\"number\">200</span>), n);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step1</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`step1 with <span class=\"subst\">$&#123;n&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> takeLongTime(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step2</span>(<span class=\"params\">m, n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`step2 with <span class=\"subst\">$&#123;m&#125;</span> and <span class=\"subst\">$&#123;n&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> takeLongTime(m + n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step3</span>(<span class=\"params\">k, m, n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`step3 with <span class=\"subst\">$&#123;k&#125;</span>, <span class=\"subst\">$&#123;m&#125;</span> and <span class=\"subst\">$&#123;n&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> takeLongTime(k + m + n);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>async</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doIt</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">\"doIt\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> time1 = <span class=\"number\">300</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> time2 = <span class=\"keyword\">await</span> step1(time1);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> time3 = <span class=\"keyword\">await</span> step2(time1, time2);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> step3(time1, time2, time3);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`result is <span class=\"subst\">$&#123;result&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">\"doIt\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">doIt();</span><br></pre></td></tr></table></figure></p>\n<p><strong>promise</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doIt</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">\"doIt\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> time1 = <span class=\"number\">300</span>;</span><br><span class=\"line\">    step1(time1)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">time2</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> step2(time1, time2)</span><br><span class=\"line\">                .then(<span class=\"function\"><span class=\"params\">time3</span> =&gt;</span> [time1, time2, time3]);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">times</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> [time1, time2, time3] = times;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> step3(time1, time2, time3);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">`result is <span class=\"subst\">$&#123;result&#125;</span>`</span>);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">\"doIt\"</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">doIt();</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><ul>\n<li>async和co都是可以使用try/catch的。</li>\n<li>await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try/catch代码块中。</li>\n<li>thunk：不讲了。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>Javascript语言的执行环境是”单线程”,如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。</p>\n<ul>\n<li>好处：实现起来比较简单，执行环境相对单纯；</li>\n<li>坏处：只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。</li>\n<li>解决办法：Javascript语言将任务的执行模式分成两种：同步和异步。</li>\n</ul>\n<h2 id=\"js中异步的几种方式\"><a href=\"#js中异步的几种方式\" class=\"headerlink\" title=\"js中异步的几种方式\"></a>js中异步的几种方式</h2><h3 id=\"1-callback\"><a href=\"#1-callback\" class=\"headerlink\" title=\"1. callback\"></a>1. callback</h3><p>异步编程最基本的方法。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        callback();</span><br><span class=\"line\">    &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>缺点：耦合度高，不利于代码维护；而且每个任务只能指定一个回调函数。</p>\n<h3 id=\"2-event\"><a href=\"#2-event\" class=\"headerlink\" title=\"2. event\"></a>2. event</h3><p>使用事件驱动的模式。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1.on(<span class=\"string\">'wtf'</span>, f2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        f1.trigger(<span class=\"string\">'wtf'</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>能够去耦合，但是整个程序都变成了事件驱动，运行流程会变得很不清晰，不符合人脑习惯（顺序）。</p>\n<h3 id=\"3-promise\"><a href=\"#3-promise\" class=\"headerlink\" title=\"3. promise\"></a>3. promise</h3><p>CommongJS提出的规范，现在已经被纳入ES6标准。目的是为异步编程提供统一接口。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//do something</span></span><br><span class=\"line\">        ajax.get.apply(ajax, args.concat([<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (data.status == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                resolve(data);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                reject(data);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;]));</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f1(<span class=\"string\">'/flight/air'</span>, &#123;<span class=\"attr\">from</span>: <span class=\"string\">'北京'</span>, <span class=\"attr\">arrive</span>: <span class=\"string\">'上海'</span>&#125;)</span><br><span class=\"line\">.then(f2)</span><br><span class=\"line\">.catch(f3);</span><br></pre></td></tr></table></figure></p>\n<p>Promise方法和它的字面意思一样，保证了代码先后的执行顺序。以往的回调可以使用Promise封装，封装后的代码写起来是顺序执行的，符合人的思考方式，也便于阅读和维护。</p>\n<p>另外Promise对象同样可以返回一个新的Promise对象，能够采用链式写法，摆脱了callback hell。</p>\n<h3 id=\"4-co\"><a href=\"#4-co\" class=\"headerlink\" title=\"4. co\"></a>4. co</h3><p>co是一个异步模块，它基于ES6的generator和yield，让我们能够用同步的形式编写异步代码。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">co(<span class=\"function\"><span class=\"keyword\">function</span> *(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> data = <span class=\"keyword\">yield</span> $.get(<span class=\"string\">'/flight/data'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> user = <span class=\"keyword\">yield</span> $.get(<span class=\"string\">'/flight/user'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(user);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> air = <span class=\"keyword\">yield</span> $.get(<span class=\"string\">'/flight/air'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(air);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>generator本来就是一个迭代器生成器，但是被<a href=\"http://tjholowaychuk.com/\" target=\"_blank\" rel=\"noopener\">TJ</a>这个大神给创造性的拿来解决异步流程问题了，膜。</p>\n<blockquote>\n<p>TJ Holowaychuk，程序员兼艺术家，Koa、Co、Express、jade、mocha、node-canvas、commander.js等知名开源项目的创建和贡献者。</p>\n</blockquote>\n<h3 id=\"5-async\"><a href=\"#5-async\" class=\"headerlink\" title=\"5. async\"></a>5. async</h3><p>async/await其实和co是类似的东西，可以说是将co的方案纳入了ES7标准，类似于一个语法糖。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//node version at least 7.0.0</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      resolve(<span class=\"number\">123</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> testAsync = <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> t = <span class=\"keyword\">await</span> f();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(t);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">testAsync();</span><br></pre></td></tr></table></figure></p>\n<p>async/await被称作是异步编程终极解决方案，他让整个流程真正看起来像是按照代码顺序同步执行，而且还有其它的优点。</p>\n<hr>\n<h2 id=\"co\"><a href=\"#co\" class=\"headerlink\" title=\"co\"></a>co</h2><p>co模块的简单思路：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">co</span>(<span class=\"params\">gen</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> it = gen();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ret = it.next();</span><br><span class=\"line\">    ret.value.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">        it.next(res);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>generator函数体可以停在yield语句处，直到下一次执行next()。co模块的思路就是利用这个特性，将异步操作跟在yield后面，当异步操作完成并返回结果后，再触发下一次next()。</p>\n<blockquote>\n<p>跟在yield后面的异步操作需要遵循一定的规范：<strong>promise</strong>和thunk。</p>\n</blockquote>\n<h2 id=\"async\"><a href=\"#async\" class=\"headerlink\" title=\"async\"></a>async</h2><p>async/await可以说是对于异步编程比较简单好用的方案，对于不是很复杂的用例下已经够用了。</p>\n<blockquote>\n<p>await等待的是一个表达式，这个表达式的计算结果是 Promise对象或者其它值。如果它等到的不是一个Promise对象，那await表达式的运算结果就是它等到的东西；如果它等到的是一个Promise对象，await就忙起来了，它会阻塞后面的代码，等着Promise对象resolve，然后得到resolve的值，作为await表达式的运算结果。</p>\n<p>因为async函数返回一个Promise对象，所以await可以用于等待一个async函数的返回值。</p>\n</blockquote>\n<h4 id=\"async-await的优势？\"><a href=\"#async-await的优势？\" class=\"headerlink\" title=\"async/await的优势？\"></a>async/await的优势？</h4><ul>\n<li>处理then链</li>\n<li>解决Promise参数传递过于麻烦的问题</li>\n</ul>\n<p><strong>Demo</strong>：对于一个业务，分三个步骤(step1,step2,step3)，每个步骤都是异步的，并且依赖于上一个步骤的结果。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">takeLongTime</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve(n + <span class=\"number\">200</span>), n);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step1</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`step1 with <span class=\"subst\">$&#123;n&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> takeLongTime(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step2</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`step2 with <span class=\"subst\">$&#123;n&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> takeLongTime(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step3</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`step3 with <span class=\"subst\">$&#123;n&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> takeLongTime(n);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>promise</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doIt</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">\"doIt\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> time1 = <span class=\"number\">300</span>;</span><br><span class=\"line\">    step1(time1)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">time2</span> =&gt;</span> step2(time2))</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">time3</span> =&gt;</span> step3(time3))</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">`result is <span class=\"subst\">$&#123;result&#125;</span>`</span>);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">\"doIt\"</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">doIt();</span><br></pre></td></tr></table></figure></p>\n<p><strong>async</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doIt</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">\"doIt\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> time1 = <span class=\"number\">300</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> time2 = <span class=\"keyword\">await</span> step1(time1);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> time3 = <span class=\"keyword\">await</span> step2(time2);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> step3(time3);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`result is <span class=\"subst\">$&#123;result&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">\"doIt\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">doIt();</span><br></pre></td></tr></table></figure></p>\n<p><strong>Demo</strong>：每一步都需要之前所有步骤的结果。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">takeLongTime</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve(n + <span class=\"number\">200</span>), n);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step1</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`step1 with <span class=\"subst\">$&#123;n&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> takeLongTime(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step2</span>(<span class=\"params\">m, n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`step2 with <span class=\"subst\">$&#123;m&#125;</span> and <span class=\"subst\">$&#123;n&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> takeLongTime(m + n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step3</span>(<span class=\"params\">k, m, n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`step3 with <span class=\"subst\">$&#123;k&#125;</span>, <span class=\"subst\">$&#123;m&#125;</span> and <span class=\"subst\">$&#123;n&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> takeLongTime(k + m + n);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>async</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doIt</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">\"doIt\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> time1 = <span class=\"number\">300</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> time2 = <span class=\"keyword\">await</span> step1(time1);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> time3 = <span class=\"keyword\">await</span> step2(time1, time2);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> step3(time1, time2, time3);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`result is <span class=\"subst\">$&#123;result&#125;</span>`</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">\"doIt\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">doIt();</span><br></pre></td></tr></table></figure></p>\n<p><strong>promise</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doIt</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.time(<span class=\"string\">\"doIt\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> time1 = <span class=\"number\">300</span>;</span><br><span class=\"line\">    step1(time1)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">time2</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> step2(time1, time2)</span><br><span class=\"line\">                .then(<span class=\"function\"><span class=\"params\">time3</span> =&gt;</span> [time1, time2, time3]);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">times</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> [time1, time2, time3] = times;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> step3(time1, time2, time3);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">`result is <span class=\"subst\">$&#123;result&#125;</span>`</span>);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">\"doIt\"</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">doIt();</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><ul>\n<li>async和co都是可以使用try/catch的。</li>\n<li>await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try/catch代码块中。</li>\n<li>thunk：不讲了。</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}